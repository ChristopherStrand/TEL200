\documentclass[a4paper,12pt]{article}
\usepackage{amsmath}
\usepackage[utf8]{inputenc}  
\usepackage{graphicx}       
\usepackage{geometry}
\usepackage{parskip}

\geometry{a4paper, margin=2.5cm} 

\title{TEL200 - ABB RobotStudio and YuMi Project}
\author{J\o rgen Asmundvaag \\ Ludvik H\o iberg-Aslaksen \\ Christopher Ljosland Strand}
\date{March 2025}

\begin{document}

\maketitle

\newpage
\section{Abstract}
\section{Introduction}
Industrial robotics plays an increasingly vital role in enhancing productivity, precision, and efficiency within modern manufacturing processes. ABB RobotStudio and RAPID provides a powerful platform for simulating and optimizing robotic operations in a virtual environment prior to physical implementation.

In this project, we use ABB's RobotStudio simulation environment to develop, simulate, and deploy two different applications as described in the task description. 

The first application involves precisely picking up objects and moving them to another designated location at the click of a button, with additional safety functionality integrated through an emergency button.

The second application is the YuMi challenge where we were given an open task to test the capabilities of the YuMi robot. Inspired by the 18th century famous machine that fascinated audiences across Europe, "The Turk". As The Turk, we won´t either play fully autonomous and will use scholar´s mate to make it possible to finish within the given time frame. This  will provide an understanding of the functionality of YuMi robot and it´s capabilities doing precise tasks.

The report provides detailed insights into the methods, procedures, and results achieved through these applications, emphasizing practical experiences and theoretical connections drawn from the course syllabus.

\section{Method}
\subsection{Theory}
In this chapter, some important concepts are presented to help understand how a robotic arm moves.

\subsubsection{Pose in 3 dimensions}
The pose of an object describes its position and orientation relative to a known reference point. It can be mathematically represented using a homogeneous transformation matrix:

\[
T = 
\begin{bmatrix}
R & t \\
0 & 1
\end{bmatrix}
\]

- \( R \) represents orientation (rotation matrix).
\\
- \( t \) represents position (translation vector).

In two-dimensional (2D) space, the homogeneous transformation matrix is:
\[
T =
\begin{bmatrix}
r_{11} & r_{12} & x \\
r_{21} & r_{22} & y \\
0 & 0 & 1
\end{bmatrix}
\]

In three-dimensional (3D) space, the matrix expands to:
\[
T = 
\begin{bmatrix}
r_{11} & r_{12} & r_{13} & x \\
r_{21} & r_{22} & r_{23} & y \\
r_{31} & r_{32} & r_{33} & z \\
0 & 0 & 0 & 1
\end{bmatrix}
\]

\subsubsection{Path and Trajectory}
A path describes how the robot moves from one pose to another without specifying timing details. A trajectory, however, is a path combined with timing information, specifying when and how quickly the robot moves through each point along the path.

\subsubsection{Joint space vs. Cartesian space}
When moving the robotic arm, you must decide whether to calculate the motion using joint space or Cartesian space:

- \textbf{Joint space} describes the robot's position based on its joint angles. Paths in joint space are mathematically simple to compute but usually don't result in straight-line paths for the robot's tool. This can cause problems for tasks that require precise linear movements, like welding. Because joint space plans motion based solely on joint angles, the end-effector's actual path can differ from what is desired.

- \textbf{Cartesian space} directly considers the position of the robot's tool (end-effector). Cartesian paths ensure more precise, straight-line movements, ideal for tasks needing high accuracy. However, these calculations are more complex and may lead to very high joint velocities, particularly near singularities, which are positions where the robot has limited movement capabilities and might struggle to perform smooth motions.

\subsubsection{Singularities}
Singularities are specific robot poses where it loses the ability to freely move in certain directions. Near singularities, joint velocities can become very high, potentially causing mechanical issues or imprecise movements.

The YuMi robot, with its seven joints, experiences fewer singularities and can easily reach most points within its workspace, making it highly suitable for versatile tasks. Robots specifically designed for a certain task may not require many joints, but their reduced flexibility might cause problems if their operating conditions change unexpectedly.



\subsection{YuMi Application}
The workstation is composed of a cube, cylinder and prism and two slots for each where the task it to move these from one of the slots to the other one and back on the press of a button.
The YuMi application will not need any modifications to the models as these were already implemented.
\subsubsection{Creating the paths and targets}
the slots are places in a 3x3 grid where the coloums (x axis) is the slots and the rows (y axis) are the slots for each body, coordinate system defined from the table. The distance between the center of each slot is 100 mm. The task is to move the bodies from col 1->3 or vice-versa. 
As the gripper has a local coordinate system and as the gripper will try to match its coordinate system with body we have to rotate all the points local coordinate system 180 degrees, either x or y (we used x).
Grabbing the cube is quite simple, we defined one point lower where it´s grabbing the cube and one above, each side, to avoid collision with the slots and/or drag. The path used these points to move the body from one side to the other.
Cylinder is very similar and no need for much extra, but important to be centered for it to hold.
Prism differs slightly from the other objects, for grabbing the the prism you need to rotate the local coordinate system 90 degrees for it to grab on the corner and the middle on the side for it to hold.  

\subsubsection{Code Structure and Timings}
The upper section within the module contains all the defined targets and two important variables: speed and precision. These variables control the simulation's speed and the precision of the YuMi robot's movements.

The main part of the RAPID code consists of a continuously running while loop, ensuring constant execution. Inside this loop, multiple if statements check the status of buttons connected to the YuMi robot. Nested within these conditions are additional checks that determine the direction of movement for each object. Each of these statements calls specific functions to perform the required movements.

For example, when the green button \textit{di\_cube} is pressed, the program first determines the direction the cube should move, subsequently calling either the \textit{cube\_left\_right} or \textit{cube\_right\_left} functions. These functions guide the robot to an upper target point, open the gripper, move down to grasp the object, close the gripper, move back up, transfer to the opposite side, descend again, release the object, and finally return to the starting position.

The same logic and procedure apply similarly for the cylinder and prism.





\subsubsection{Simulating Movement Of The Emergency Button}
The first step towards animating the button is to separate the button and base objects from each other. 
DESCRIBE HOW SEPARATE. 
CREATE MECHANISM
SMART COMPONENT (POSE MOVER and LOGIC GATE)
STATION LOGIC
OUTPUT SIGNAL AND WHY


\subsection{YuMi Challenge}
\subsubsection{CAD geometry}
\textbf{Jørgen fikser hvordan lage sjakkbrett!!!!}

To be able to get accurate placements of the chess pieces, we modeled a chess board using the Rectangle surface geometry option in RobotStudio. Here we created a 25x25mm square surface, and created a chess board from 64 of these. We centered the board axis to align with the target of the wobj0, to simplify our setup process. We also aligned the border of the board 200 mm from the wobj0 target. 
We created targets for the center of each chess board square, to place the pieces correctly. 

To create our CAD geometry we used a 3D-scanner borrowed from Eiklab to make a 3D object of each type of chess piece. We then imported each 3D file into Fusion360 where we performed the following steps.
\begin{enumerate}
    \item Mesh $\rightarrow$ Insert $\rightarrow$ Insert Mesh
    \item Rotated the chess pieces such that they are straight
    \item Exported them as .sat files
\end{enumerate}
We then imported the .sat files into Robotstudio using the import CAD geometry button. When the chess pieces are imported we needed to move them their correct spaces on the chess board. This was done by trial and error, and duplicate button was used to get pieces which have multiples.

\subsubsection{Creating the paths and targets}
\label{sec:Challenge_paths_targets}
When creating the paths, we based the targets on the following chess moves.

\begin{table}[h] %Scholar's mate moves
    \centering
    \begin{tabular}{c l l}
        \hline
        Move & White & Black \\
        \hline
        1. & e4 & e5 \\
        2. & Dh5 & Sc6 \\
        3. & Lc4 & Sf6?? \\
        4. & Dxf7 & (checkmate) \\
        \hline
    \end{tabular}
    \caption{Scholar's Mate}
    \label{tab:chess_moves}
\end{table}
To make the YuMi Robot's moves as clean as possible it is important to have two targets above the desired destination. One that is about 5 mm above the chess piece and one that is higher in the range 25-50 mm above the piece. This allows the YuMi Robot to move smoothly between each target. Due to the 3D-scans being somewhat inaccurate the distances specified before may need some adjustments depending on the piece and quality of the model.

To simplify the paths the YuMi Robot returns to a set point after picking up or placing a piece. This point is centered above the queen with a 25 mm offset towards the YuMi Robot. 

After the paths have been created it is important to note that a fully extended gripper would collide with pieces surrounding the piece to be picked up. To solve this the rapid command \textit{g\_MoveTo value;} was used. This command extends the gripper to the specified value allowing the gripper to easily slide between the pieces. The space between chess pieces is about 7 mm for the large pieces and about 8 mm for pawns.

After YuMi robot has won the game it will do a little victory dance by simply moving the arm up in the air up and down. To get this to work it also has to be implemented a helping point, as moving from start position straight up would cause a collision. Therefore, by putting a helping point in front and up from the robot then returning back to y axis it will be able to safely perform the victory dance. 

\subsubsection{Code structure and timings}
The top part located within the module part consist of all the targets and two variables called speed and precision. The variables control the simulation speed and precision of the YuMi Robot. The main body of the Rapid code consists of while loop that is constantly true allowing the code to run in a loop, within the while loop the code has several if statements that check if the buttons connected to the YuMi Robot are pressed. These if statements contain the different functions for each chess move.

The green button \textit{di\_cube} when pressed runs move 1 chess move from table~\ref{tab:chess_moves}. When it is pressed a second time it runs move 2 and so on. After all moves are run it resets to move 1. The second blue button \textit{di\_cylinder} runs all moves with timing delay specified in the code by a variable. The third red button \textit{di\_prism} runs the celebration described in section \ref{sec:Challenge_paths_targets}. The fourth yellow button \textit{di\_home} returns the YuMi Robot to its start position.

The final button is an emergency stop button called \textit{di\_EmergencySituation} this button when pressed runs a trap routine that stops the YuMi Robot mid path, and when let go it starts to move from the same position it stopped. One of the main perks to using a trap routine is that it can interrupt any movement and then issue a command which the it would not be able to do with if statements.

\section{Results}
\section{Discussion}
\section{Conclusions} to the



\end{document}
